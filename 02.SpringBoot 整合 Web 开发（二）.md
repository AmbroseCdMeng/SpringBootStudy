# SpringBoot 学习笔记

> 声明：
> 
> 本次学习参考 《SpringBoot + Vue 开发实战》 · 王松（著） 一书。
> 
> 本文的目的是记录我学习的过程和遇到的一些问题以及解决办法，其内容主要来源于原书。
> 
> 如有侵权，请联系我删除

## SpringBoot 整合 Web 开发

### CORS 支持

> CORS (Cross-Origin Resource Sharing) 是一种跨域资源共享技术标准，其目的就是为了解决前端跨域请求。在 Java EE 中，关于前端跨域请求最常见的解决方案是 `JSONP`，但是，`JSONP` 最大的缺陷是只支持 `GET` 请求。而 `CORS` 支持多种 HTTP 请求方法。

跨域有两个地方可以配置：

- 请求方法配置

	```java
	@PostMapping("/")
    @CrossOrigin(value = "https://localhost:8080", maxAge = 1800, allowedHeaders = "*")
    public String addBook(String name){
        return "receive" + name;
    }

    @DeleteMapping("/{id}")
    @CrossOrigin(value = "https://localhost:8080", maxAge = 1800, allowedHeaders = "*")
    public String deleteBookById(@PathVariable Long id){
        return String.valueOf(id);
    }
	```

	- `@CrossOrigin` 中的 `value` 表示支持的域，这里表示 `https://localhost:8080` 域的请求支持跨域
	- `maxAge` 表示探测请求的有效期。在请求执行过程中会先发送探测请求，探测请求不是每次都发送，可以配置一个周期，过了有效期再次发送，默认 1800 秒
	- `allowedHeaders` 表示允许的请求头， `*` 表示所有请求头都被允许

- 全局配置

	```java
	@Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/book/**")
                .allowedHeaders("*")
                .allowedMethods("*")
                .maxAge(1800)
                .allowedOrigins("https://localhost:8080");
    }
	```
	

### 配置类和 XML 配置

> SpringBoot 推荐使用 Java 来完成相关配置工作，这些配置类需要添加 `@Configuration` 注解， `@ComponentScan` 注解会扫描所有 Spring 组件，也包括 `@Configuration`。 `@ComponentScan` 注解在项目入口类的 `@SpringBootApplication` 注解中已经提供，因此在实际项目中只需要按需提供相关配置类即可。

### 注册拦截器

> SpringMVC 中提供了 `AOP` 风格的拦截器，拥有更加精细的拦截处理能力。 SpringBoot 的拦截器注册更加方便。

- 创建拦截器

```java
public class MyInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        System.out.println("MyInterceptor >>>>> preHandler");
        return true;
    }

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception {
        System.out.println("MyInterceptor >>>>> postHandler");
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        System.out.println("MyInterceptor >>>>> afterCompletion");
    }
}
```

> 按照 preHandle - Controller - postHandle - afterCompletion 的顺序依次执行， 当且仅当 preHandler 返回 true 时，后面的才会继续
> 
> 当拦截器链内有多个拦截器时，postHandler 在拦截器链内所有拦截器返回成功时才会调用，而 afterCompletion 只有 preHandler 返回 true 才调用

- 配置拦截器

```java
@Configuration
public class MyWebMvcConfig implements WebMvcConfigurer {

    /**
     * 拦截器配置
     * @param registry
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(new MyInterceptor())
                .addPathPatterns("/**")         //拦截路径
                .excludePathPatterns("/hello"); //排除路径
    }
}
```

### 启动系统任务

### 整合 Servlet、Filter 和 Listener

### 路径映射

### 配置 AOP

### 其他

